# 新算子支持与测试

2025-03-27, SUSTech, AoShen

## 算子支持

当前阶段，此编译框架足以支持所有的硬件算子的编译需求，所以，对于新的硬件以及硬件对应新的算子的支持为当前开发的主要任务之一。如何尽可能简便的对新硬件和新算子做添加是需要认真考虑的编译器设计。当前，为了适配编译器的桥接/转换/映射任务，需要在硬件算子和软件算子之间做出折中选择。由于硬件算子过于独特（如fp16 x fp16与fp16 x int4理论上是两个硬件算子），而软件算子过于泛化（对于硬件算子来说都可描述为linear或matmul），所以在设计时尽可能同时适配软硬件。因此，在新算子支持时尽可能满足以下设计思想：

1. 算子Op对象提供了注册Attribute的能力，尽可能的将对应算子的硬件特性转换为算子的Attribute特性
2. 对于新的硬件，尽可能不注册新的算子，而是在对应的已注册的算子中添加属于其新硬件的Attribute以做支持
3. 硬件提供的testbench很多情况下并不需要与编译器的算子数量一一对应，而是可以进行一定程度将多个testbench融合为一个算子
4. 在编写硬件driver时，多使用Tasks模块做管理，并且尽可能以函数化、模块化进行管理，方便随时更新驱动

添加算子支持的过程可参考DLAVM_Compiler.md内容

新的特性可以ohbm为硬件设备，参考dlavm/op/nn/_nn.py和dlavm/op/nn/_ohbm.py，其中，_hh.py为通用的算子Attribute，而_ohbm.py为ohbm专用的算子Attribute，以此做区分。其中，对于新硬件设备的添加可参考dlavm/device中的已实现内容，主要核心为继承Accel类，并实现name，version以及malloc_bytes函数等

## 算子测试

对于算子测试，之前的测试方式十分粗略，仅通过手动编译结果和tb对比即可。然而，随着编译难度上升，算子越来越复杂，静态算子的对比依然较为方便，但是对于动态算子的对比，如果没有新的工具支持就极为繁琐。以下就是当前工程中做的提升：

1. 对于静态算子的检查，首先将算子通过tb和编译器分别编译，并对编译器的结果进行额外优化，主要进行循环展开，并将两种编译方法的寄存器读写的参数序列化存储到列表中，通过对列表的对比来实现算子检查，具体可参考script/only_hbm/compare.py，然而，此方法跳过了地址方面的检查，因为地址被额外设定为符号表达式
2. 对于动态算子的检查，必须与静态算子结合，因为tb编译过程仅能对静态算子有效。而动态算子进行常规编译后，将编译结果放入runtime模块，通过改写寄存器读写的方法，将其存储到列表中实现。此方法即为类似在虚拟设备中运行了实际的编译代码，准确性更高，可参考script/only_hbm/runtime_test.py，并且其通过对比地址信息的offset进行一定程度上检查。然而，对于地址空间大小的检查目前无法通过此方式实现。