// generated by codegen c++ test ops head at 2024-09-27 10:41:28
// global storage define
uint64_t global0 = 0x000000000; // storage size: 524288 B
uint64_t global1 = 0x000080000; // storage size: 8192 B
// weight storage define
uint64_t weight0 = 0x000082000; // storage size: 14336 B
uint64_t weight1 = 0x000085800; // storage size: 14336 B
uint64_t weight2 = 0x000089000; // storage size: 2048 B
uint64_t weight3 = 0x000089800; // storage size: 2048 B
uint64_t weight4 = 0x00008a000; // storage size: 14336 B
uint64_t weight5 = 0x00008d800; // storage size: 14336 B
uint64_t weight6 = 0x000091000; // storage size: 75776 B
uint64_t weight7 = 0x0000a3800; // storage size: 75776 B
uint64_t weight8 = 0x0000b6000; // storage size: 14336 B
uint64_t weight9 = 0x0000b9800; // storage size: 14336 B
uint64_t weight10 = 0x0000bd000; // storage size: 14336 B
uint64_t weight11 = 0x0000c0800; // storage size: 2048 B
uint64_t weight12 = 0x0000c1000; // storage size: 2048 B
uint64_t weight13 = 0x0000c1800; // storage size: 14336 B
uint64_t weight14 = 0x0000c5000; // storage size: 14336 B
uint64_t weight15 = 0x0000c8800; // storage size: 75776 B
uint64_t weight16 = 0x0000db000; // storage size: 75776 B
uint64_t weight17 = 0x0000ed800; // storage size: 14336 B
uint64_t weight18 = 0x0000f1000; // storage size: 14336 B
uint64_t weight19 = 0x0000f4800; // storage size: 14336 B
uint64_t weight20 = 0x0000f8000; // storage size: 2048 B
uint64_t weight21 = 0x0000f8800; // storage size: 2048 B
uint64_t weight22 = 0x0000f9000; // storage size: 14336 B
uint64_t weight23 = 0x0000fc800; // storage size: 14336 B
uint64_t weight24 = 0x000100000; // storage size: 75776 B
uint64_t weight25 = 0x000112800; // storage size: 75776 B
uint64_t weight26 = 0x000125000; // storage size: 14336 B
uint64_t weight27 = 0x000128800; // storage size: 14336 B
uint64_t weight28 = 0x00012c000; // storage size: 14336 B
uint64_t weight29 = 0x00012f800; // storage size: 2048 B
uint64_t weight30 = 0x000130000; // storage size: 2048 B
uint64_t weight31 = 0x000130800; // storage size: 14336 B
uint64_t weight32 = 0x000134000; // storage size: 14336 B
uint64_t weight33 = 0x000137800; // storage size: 75776 B
uint64_t weight34 = 0x00014a000; // storage size: 75776 B
uint64_t weight35 = 0x00015c800; // storage size: 14336 B
uint64_t weight36 = 0x000160000; // storage size: 14336 B
uint64_t weight37 = 0x000163800; // storage size: 14336 B
uint64_t weight38 = 0x000167000; // storage size: 2048 B
uint64_t weight39 = 0x000167800; // storage size: 2048 B
uint64_t weight40 = 0x000168000; // storage size: 14336 B
uint64_t weight41 = 0x00016b800; // storage size: 14336 B
uint64_t weight42 = 0x00016f000; // storage size: 75776 B
uint64_t weight43 = 0x000181800; // storage size: 75776 B
uint64_t weight44 = 0x000194000; // storage size: 14336 B
uint64_t weight45 = 0x000197800; // storage size: 14336 B
uint64_t weight46 = 0x00019b000; // storage size: 14336 B
uint64_t weight47 = 0x00019e800; // storage size: 2048 B
uint64_t weight48 = 0x00019f000; // storage size: 2048 B
uint64_t weight49 = 0x00019f800; // storage size: 14336 B
uint64_t weight50 = 0x0001a3000; // storage size: 14336 B
uint64_t weight51 = 0x0001a6800; // storage size: 75776 B
uint64_t weight52 = 0x0001b9000; // storage size: 75776 B
uint64_t weight53 = 0x0001cb800; // storage size: 14336 B
uint64_t weight54 = 0x0001cf000; // storage size: 14336 B
uint64_t weight55 = 0x0001d2800; // storage size: 14336 B
uint64_t weight56 = 0x0001d6000; // storage size: 2048 B
uint64_t weight57 = 0x0001d6800; // storage size: 2048 B
uint64_t weight58 = 0x0001d7000; // storage size: 14336 B
uint64_t weight59 = 0x0001da800; // storage size: 14336 B
uint64_t weight60 = 0x0001de000; // storage size: 75776 B
uint64_t weight61 = 0x0001f0800; // storage size: 75776 B
uint64_t weight62 = 0x000203000; // storage size: 14336 B
uint64_t weight63 = 0x000206800; // storage size: 14336 B
uint64_t weight64 = 0x00020a000; // storage size: 14336 B
uint64_t weight65 = 0x00020d800; // storage size: 2048 B
uint64_t weight66 = 0x00020e000; // storage size: 2048 B
uint64_t weight67 = 0x00020e800; // storage size: 14336 B
uint64_t weight68 = 0x000212000; // storage size: 14336 B
uint64_t weight69 = 0x000215800; // storage size: 75776 B
uint64_t weight70 = 0x000228000; // storage size: 75776 B
uint64_t weight71 = 0x00023a800; // storage size: 14336 B
uint64_t weight72 = 0x00023e000; // storage size: 14336 B
uint64_t weight73 = 0x000241800; // storage size: 14336 B
uint64_t weight74 = 0x000245000; // storage size: 2048 B
uint64_t weight75 = 0x000245800; // storage size: 2048 B
uint64_t weight76 = 0x000246000; // storage size: 14336 B
uint64_t weight77 = 0x000249800; // storage size: 14336 B
uint64_t weight78 = 0x00024d000; // storage size: 75776 B
uint64_t weight79 = 0x00025f800; // storage size: 75776 B
uint64_t weight80 = 0x000272000; // storage size: 14336 B
uint64_t weight81 = 0x000275800; // storage size: 14336 B
uint64_t weight82 = 0x000279000; // storage size: 14336 B
uint64_t weight83 = 0x00027c800; // storage size: 2048 B
uint64_t weight84 = 0x00027d000; // storage size: 2048 B
uint64_t weight85 = 0x00027d800; // storage size: 14336 B
uint64_t weight86 = 0x000281000; // storage size: 14336 B
uint64_t weight87 = 0x000284800; // storage size: 75776 B
uint64_t weight88 = 0x000297000; // storage size: 75776 B
uint64_t weight89 = 0x0002a9800; // storage size: 14336 B
uint64_t weight90 = 0x0002ad000; // storage size: 14336 B
uint64_t weight91 = 0x0002b0800; // storage size: 14336 B
uint64_t weight92 = 0x0002b4000; // storage size: 2048 B
uint64_t weight93 = 0x0002b4800; // storage size: 2048 B
uint64_t weight94 = 0x0002b5000; // storage size: 14336 B
uint64_t weight95 = 0x0002b8800; // storage size: 14336 B
uint64_t weight96 = 0x0002bc000; // storage size: 75776 B
uint64_t weight97 = 0x0002ce800; // storage size: 75776 B
uint64_t weight98 = 0x0002e1000; // storage size: 14336 B
uint64_t weight99 = 0x0002e4800; // storage size: 14336 B
uint64_t weight100 = 0x0002e8000; // storage size: 14336 B
uint64_t weight101 = 0x0002eb800; // storage size: 2048 B
uint64_t weight102 = 0x0002ec000; // storage size: 2048 B
uint64_t weight103 = 0x0002ec800; // storage size: 14336 B
uint64_t weight104 = 0x0002f0000; // storage size: 14336 B
uint64_t weight105 = 0x0002f3800; // storage size: 75776 B
uint64_t weight106 = 0x000306000; // storage size: 75776 B
uint64_t weight107 = 0x000318800; // storage size: 14336 B
uint64_t weight108 = 0x00031c000; // storage size: 14336 B
uint64_t weight109 = 0x00031f800; // storage size: 14336 B
uint64_t weight110 = 0x000323000; // storage size: 2048 B
uint64_t weight111 = 0x000323800; // storage size: 2048 B
uint64_t weight112 = 0x000324000; // storage size: 14336 B
uint64_t weight113 = 0x000327800; // storage size: 14336 B
uint64_t weight114 = 0x00032b000; // storage size: 75776 B
uint64_t weight115 = 0x00033d800; // storage size: 75776 B
uint64_t weight116 = 0x000350000; // storage size: 14336 B
uint64_t weight117 = 0x000353800; // storage size: 14336 B
uint64_t weight118 = 0x000357000; // storage size: 14336 B
uint64_t weight119 = 0x00035a800; // storage size: 2048 B
uint64_t weight120 = 0x00035b000; // storage size: 2048 B
uint64_t weight121 = 0x00035b800; // storage size: 14336 B
uint64_t weight122 = 0x00035f000; // storage size: 14336 B
uint64_t weight123 = 0x000362800; // storage size: 75776 B
uint64_t weight124 = 0x000375000; // storage size: 75776 B
uint64_t weight125 = 0x000387800; // storage size: 14336 B
uint64_t weight126 = 0x00038b000; // storage size: 14336 B
uint64_t weight127 = 0x00038e800; // storage size: 14336 B
uint64_t weight128 = 0x000392000; // storage size: 2048 B
uint64_t weight129 = 0x000392800; // storage size: 2048 B
uint64_t weight130 = 0x000393000; // storage size: 14336 B
uint64_t weight131 = 0x000396800; // storage size: 14336 B
uint64_t weight132 = 0x00039a000; // storage size: 75776 B
uint64_t weight133 = 0x0003ac800; // storage size: 75776 B
uint64_t weight134 = 0x0003bf000; // storage size: 14336 B
uint64_t weight135 = 0x0003c2800; // storage size: 14336 B
uint64_t weight136 = 0x0003c6000; // storage size: 14336 B
uint64_t weight137 = 0x0003c9800; // storage size: 2048 B
uint64_t weight138 = 0x0003ca000; // storage size: 2048 B
uint64_t weight139 = 0x0003ca800; // storage size: 14336 B
uint64_t weight140 = 0x0003ce000; // storage size: 14336 B
uint64_t weight141 = 0x0003d1800; // storage size: 75776 B
uint64_t weight142 = 0x0003e4000; // storage size: 75776 B
uint64_t weight143 = 0x0003f6800; // storage size: 14336 B
uint64_t weight144 = 0x0003fa000; // storage size: 14336 B
uint64_t weight145 = 0x0003fd800; // storage size: 14336 B
uint64_t weight146 = 0x000401000; // storage size: 2048 B
uint64_t weight147 = 0x000401800; // storage size: 2048 B
uint64_t weight148 = 0x000402000; // storage size: 14336 B
uint64_t weight149 = 0x000405800; // storage size: 14336 B
uint64_t weight150 = 0x000409000; // storage size: 75776 B
uint64_t weight151 = 0x00041b800; // storage size: 75776 B
uint64_t weight152 = 0x00042e000; // storage size: 14336 B
uint64_t weight153 = 0x000431800; // storage size: 14336 B
uint64_t weight154 = 0x000435000; // storage size: 14336 B
uint64_t weight155 = 0x000438800; // storage size: 2048 B
uint64_t weight156 = 0x000439000; // storage size: 2048 B
uint64_t weight157 = 0x000439800; // storage size: 14336 B
uint64_t weight158 = 0x00043d000; // storage size: 14336 B
uint64_t weight159 = 0x000440800; // storage size: 75776 B
uint64_t weight160 = 0x000453000; // storage size: 75776 B
uint64_t weight161 = 0x000465800; // storage size: 14336 B
uint64_t weight162 = 0x000469000; // storage size: 14336 B
uint64_t weight163 = 0x00046c800; // storage size: 14336 B
uint64_t weight164 = 0x000470000; // storage size: 2048 B
uint64_t weight165 = 0x000470800; // storage size: 2048 B
uint64_t weight166 = 0x000471000; // storage size: 14336 B
uint64_t weight167 = 0x000474800; // storage size: 14336 B
uint64_t weight168 = 0x000478000; // storage size: 75776 B
uint64_t weight169 = 0x00048a800; // storage size: 75776 B
uint64_t weight170 = 0x00049d000; // storage size: 14336 B
uint64_t weight171 = 0x0004a0800; // storage size: 14336 B
uint64_t weight172 = 0x0004a4000; // storage size: 14336 B
uint64_t weight173 = 0x0004a7800; // storage size: 2048 B
uint64_t weight174 = 0x0004a8000; // storage size: 2048 B
uint64_t weight175 = 0x0004a8800; // storage size: 14336 B
uint64_t weight176 = 0x0004ac000; // storage size: 14336 B
uint64_t weight177 = 0x0004af800; // storage size: 75776 B
uint64_t weight178 = 0x0004c2000; // storage size: 75776 B
uint64_t weight179 = 0x0004d4800; // storage size: 14336 B
uint64_t weight180 = 0x0004d8000; // storage size: 14336 B
uint64_t weight181 = 0x0004db800; // storage size: 14336 B
uint64_t weight182 = 0x0004df000; // storage size: 2048 B
uint64_t weight183 = 0x0004df800; // storage size: 2048 B
uint64_t weight184 = 0x0004e0000; // storage size: 14336 B
uint64_t weight185 = 0x0004e3800; // storage size: 14336 B
uint64_t weight186 = 0x0004e7000; // storage size: 75776 B
uint64_t weight187 = 0x0004f9800; // storage size: 75776 B
uint64_t weight188 = 0x00050c000; // storage size: 14336 B
uint64_t weight189 = 0x00050f800; // storage size: 14336 B
uint64_t weight190 = 0x000513000; // storage size: 14336 B
uint64_t weight191 = 0x000516800; // storage size: 2048 B
uint64_t weight192 = 0x000517000; // storage size: 2048 B
uint64_t weight193 = 0x000517800; // storage size: 14336 B
uint64_t weight194 = 0x00051b000; // storage size: 14336 B
uint64_t weight195 = 0x00051e800; // storage size: 75776 B
uint64_t weight196 = 0x000531000; // storage size: 75776 B
uint64_t weight197 = 0x000543800; // storage size: 14336 B
uint64_t weight198 = 0x000547000; // storage size: 14336 B
uint64_t weight199 = 0x00054a800; // storage size: 14336 B
uint64_t weight200 = 0x00054e000; // storage size: 2048 B
uint64_t weight201 = 0x00054e800; // storage size: 2048 B
uint64_t weight202 = 0x00054f000; // storage size: 14336 B
uint64_t weight203 = 0x000552800; // storage size: 14336 B
uint64_t weight204 = 0x000556000; // storage size: 75776 B
uint64_t weight205 = 0x000568800; // storage size: 75776 B
uint64_t weight206 = 0x00057b000; // storage size: 14336 B
uint64_t weight207 = 0x00057e800; // storage size: 14336 B
uint64_t weight208 = 0x000582000; // storage size: 14336 B
uint64_t weight209 = 0x000585800; // storage size: 2048 B
uint64_t weight210 = 0x000586000; // storage size: 2048 B
uint64_t weight211 = 0x000586800; // storage size: 14336 B
uint64_t weight212 = 0x00058a000; // storage size: 14336 B
uint64_t weight213 = 0x00058d800; // storage size: 75776 B
uint64_t weight214 = 0x0005a0000; // storage size: 75776 B
uint64_t weight215 = 0x0005b2800; // storage size: 14336 B
uint64_t weight216 = 0x0005b6000; // storage size: 14336 B
uint64_t weight217 = 0x0005b9800; // storage size: 14336 B
uint64_t weight218 = 0x0005bd000; // storage size: 2048 B
uint64_t weight219 = 0x0005bd800; // storage size: 2048 B
uint64_t weight220 = 0x0005be000; // storage size: 14336 B
uint64_t weight221 = 0x0005c1800; // storage size: 14336 B
uint64_t weight222 = 0x0005c5000; // storage size: 75776 B
uint64_t weight223 = 0x0005d7800; // storage size: 75776 B
uint64_t weight224 = 0x0005ea000; // storage size: 14336 B
uint64_t weight225 = 0x0005ed800; // storage size: 14336 B
uint64_t weight226 = 0x0005f1000; // storage size: 14336 B
uint64_t weight227 = 0x0005f4800; // storage size: 2048 B
uint64_t weight228 = 0x0005f5000; // storage size: 2048 B
uint64_t weight229 = 0x0005f5800; // storage size: 14336 B
uint64_t weight230 = 0x0005f9000; // storage size: 14336 B
uint64_t weight231 = 0x0005fc800; // storage size: 75776 B
uint64_t weight232 = 0x00060f000; // storage size: 75776 B
uint64_t weight233 = 0x000621800; // storage size: 14336 B
uint64_t weight234 = 0x000625000; // storage size: 14336 B
uint64_t weight235 = 0x000628800; // storage size: 14336 B
uint64_t weight236 = 0x00062c000; // storage size: 2048 B
uint64_t weight237 = 0x00062c800; // storage size: 2048 B
uint64_t weight238 = 0x00062d000; // storage size: 14336 B
uint64_t weight239 = 0x000630800; // storage size: 14336 B
uint64_t weight240 = 0x000634000; // storage size: 75776 B
uint64_t weight241 = 0x000646800; // storage size: 75776 B
uint64_t weight242 = 0x000659000; // storage size: 14336 B
uint64_t weight243 = 0x00065c800; // storage size: 14336 B
uint64_t weight244 = 0x000660000; // storage size: 14336 B
uint64_t weight245 = 0x000663800; // storage size: 2048 B
uint64_t weight246 = 0x000664000; // storage size: 2048 B
uint64_t weight247 = 0x000664800; // storage size: 14336 B
uint64_t weight248 = 0x000668000; // storage size: 14336 B
uint64_t weight249 = 0x00066b800; // storage size: 75776 B
uint64_t weight250 = 0x00067e000; // storage size: 75776 B
uint64_t weight251 = 0x000690800; // storage size: 14336 B
uint64_t weight252 = 0x000694000; // storage size: 14336 B
uint64_t weight253 = 0x000697800; // storage size: 608256 B
// runtime storage define
uint64_t runtime0 =   7520256; //ADDR_A   ADDR_A ADDR_A storage size:  14680064 B -> 1024*1024*2*32=67,108,864 B
uint64_t runtime1 =  74629120; //ADDR_B  74629120 ADDR_B storage size:  77594624 B -> 1024*1024*2*32=67,108,864 B
uint64_t runtime2 = 141737984; //ADDR_C 141737984 ADDR_C storage size: 622854144 B -> 1024*1024*2*32=67,108,864 B
uint64_t runtime3 = 208846848; //ADDR_D 208846848 ADDR_D storage size: 234881024 B -> 1024*1024*2*32=67,108,864 B
uint64_t runtime4 = 275955712; //ADDR_E 275955712 ADDR_E storage size:   2097152 B -> 1024*1024*2*32=67,108,864 B
uint64_t runtime5 = 343064576; //ADDR_F 275955712 ADDR_E storage size:   2097152 B -> 1024*1024*2*32=67,108,864 B
uint64_t ADDR_A   = runtime0;
uint64_t ADDR_B   = runtime1;
uint64_t ADDR_C   = runtime2;
uint64_t ADDR_D   = runtime3;
uint64_t ADDR_E   = runtime4;
uint64_t ADDR_F   = runtime5;
 
// hbm storage define
uint64_t hbm0 = 0x000000000; // storage size: 207872 B
uint64_t hbm1 = 0x000032c00; // storage size: 29696 B
uint64_t hbm2 = 0x00003a000; // storage size: 29696 B
uint64_t hbm3 = 0x000041400; // storage size: 207872 B
uint64_t hbm4 = 0x000074000; // storage size: 1098752 B
uint64_t hbm5 = 0x000180400; // storage size: 1098752 B
uint64_t hbm6 = 0x00028c800; // storage size: 1096704 B
uint64_t hbm7 = 0x000398400; // storage size: 207872 B
uint64_t hbm8 = 0x0003cb000; // storage size: 29696 B
uint64_t hbm9 = 0x0003d2400; // storage size: 29696 B
uint64_t hbm10 = 0x0003d9800; // storage size: 207872 B
uint64_t hbm11 = 0x00040c400; // storage size: 1098752 B
uint64_t hbm12 = 0x000518800; // storage size: 1098752 B
uint64_t hbm13 = 0x000624c00; // storage size: 1096704 B
uint64_t hbm14 = 0x000730800; // storage size: 207872 B
uint64_t hbm15 = 0x000763400; // storage size: 29696 B
uint64_t hbm16 = 0x00076a800; // storage size: 29696 B
uint64_t hbm17 = 0x000771c00; // storage size: 207872 B
uint64_t hbm18 = 0x0007a4800; // storage size: 1098752 B
uint64_t hbm19 = 0x0008b0c00; // storage size: 1098752 B
uint64_t hbm20 = 0x0009bd000; // storage size: 1096704 B
uint64_t hbm21 = 0x000ac8c00; // storage size: 207872 B
uint64_t hbm22 = 0x000afb800; // storage size: 29696 B
uint64_t hbm23 = 0x000b02c00; // storage size: 29696 B
uint64_t hbm24 = 0x000b0a000; // storage size: 207872 B
uint64_t hbm25 = 0x000b3cc00; // storage size: 1098752 B
uint64_t hbm26 = 0x000c49000; // storage size: 1098752 B
uint64_t hbm27 = 0x000d55400; // storage size: 1096704 B
uint64_t hbm28 = 0x000e61000; // storage size: 207872 B
uint64_t hbm29 = 0x000e93c00; // storage size: 29696 B
uint64_t hbm30 = 0x000e9b000; // storage size: 29696 B
uint64_t hbm31 = 0x000ea2400; // storage size: 207872 B
uint64_t hbm32 = 0x000ed5000; // storage size: 1098752 B
uint64_t hbm33 = 0x000fe1400; // storage size: 1098752 B
uint64_t hbm34 = 0x0010ed800; // storage size: 1096704 B
uint64_t hbm35 = 0x0011f9400; // storage size: 207872 B
uint64_t hbm36 = 0x00122c000; // storage size: 29696 B
uint64_t hbm37 = 0x001233400; // storage size: 29696 B
uint64_t hbm38 = 0x00123a800; // storage size: 207872 B
uint64_t hbm39 = 0x00126d400; // storage size: 1098752 B
uint64_t hbm40 = 0x001379800; // storage size: 1098752 B
uint64_t hbm41 = 0x001485c00; // storage size: 1096704 B
uint64_t hbm42 = 0x001591800; // storage size: 207872 B
uint64_t hbm43 = 0x0015c4400; // storage size: 29696 B
uint64_t hbm44 = 0x0015cb800; // storage size: 29696 B
uint64_t hbm45 = 0x0015d2c00; // storage size: 207872 B
uint64_t hbm46 = 0x001605800; // storage size: 1098752 B
uint64_t hbm47 = 0x001711c00; // storage size: 1098752 B
uint64_t hbm48 = 0x00181e000; // storage size: 1096704 B
uint64_t hbm49 = 0x001929c00; // storage size: 207872 B
uint64_t hbm50 = 0x00195c800; // storage size: 29696 B
uint64_t hbm51 = 0x001963c00; // storage size: 29696 B
uint64_t hbm52 = 0x00196b000; // storage size: 207872 B
uint64_t hbm53 = 0x00199dc00; // storage size: 1098752 B
uint64_t hbm54 = 0x001aaa000; // storage size: 1098752 B
uint64_t hbm55 = 0x001bb6400; // storage size: 1096704 B
uint64_t hbm56 = 0x001cc2000; // storage size: 207872 B
uint64_t hbm57 = 0x001cf4c00; // storage size: 29696 B
uint64_t hbm58 = 0x001cfc000; // storage size: 29696 B
uint64_t hbm59 = 0x001d03400; // storage size: 207872 B
uint64_t hbm60 = 0x001d36000; // storage size: 1098752 B
uint64_t hbm61 = 0x001e42400; // storage size: 1098752 B
uint64_t hbm62 = 0x001f4e800; // storage size: 1096704 B
uint64_t hbm63 = 0x00205a400; // storage size: 207872 B
uint64_t hbm64 = 0x00208d000; // storage size: 29696 B
uint64_t hbm65 = 0x002094400; // storage size: 29696 B
uint64_t hbm66 = 0x00209b800; // storage size: 207872 B
uint64_t hbm67 = 0x0020ce400; // storage size: 1098752 B
uint64_t hbm68 = 0x0021da800; // storage size: 1098752 B
uint64_t hbm69 = 0x0022e6c00; // storage size: 1096704 B
uint64_t hbm70 = 0x0023f2800; // storage size: 207872 B
uint64_t hbm71 = 0x002425400; // storage size: 29696 B
uint64_t hbm72 = 0x00242c800; // storage size: 29696 B
uint64_t hbm73 = 0x002433c00; // storage size: 207872 B
uint64_t hbm74 = 0x002466800; // storage size: 1098752 B
uint64_t hbm75 = 0x002572c00; // storage size: 1098752 B
uint64_t hbm76 = 0x00267f000; // storage size: 1096704 B
uint64_t hbm77 = 0x00278ac00; // storage size: 207872 B
uint64_t hbm78 = 0x0027bd800; // storage size: 29696 B
uint64_t hbm79 = 0x0027c4c00; // storage size: 29696 B
uint64_t hbm80 = 0x0027cc000; // storage size: 207872 B
uint64_t hbm81 = 0x0027fec00; // storage size: 1098752 B
uint64_t hbm82 = 0x00290b000; // storage size: 1098752 B
uint64_t hbm83 = 0x002a17400; // storage size: 1096704 B
uint64_t hbm84 = 0x002b23000; // storage size: 207872 B
uint64_t hbm85 = 0x002b55c00; // storage size: 29696 B
uint64_t hbm86 = 0x002b5d000; // storage size: 29696 B
uint64_t hbm87 = 0x002b64400; // storage size: 207872 B
uint64_t hbm88 = 0x002b97000; // storage size: 1098752 B
uint64_t hbm89 = 0x002ca3400; // storage size: 1098752 B
uint64_t hbm90 = 0x002daf800; // storage size: 1096704 B
uint64_t hbm91 = 0x002ebb400; // storage size: 207872 B
uint64_t hbm92 = 0x002eee000; // storage size: 29696 B
uint64_t hbm93 = 0x002ef5400; // storage size: 29696 B
uint64_t hbm94 = 0x002efc800; // storage size: 207872 B
uint64_t hbm95 = 0x002f2f400; // storage size: 1098752 B
uint64_t hbm96 = 0x00303b800; // storage size: 1098752 B
uint64_t hbm97 = 0x003147c00; // storage size: 1096704 B
uint64_t hbm98 = 0x003253800; // storage size: 207872 B
uint64_t hbm99 = 0x003286400; // storage size: 29696 B
uint64_t hbm100 = 0x00328d800; // storage size: 29696 B
uint64_t hbm101 = 0x003294c00; // storage size: 207872 B
uint64_t hbm102 = 0x0032c7800; // storage size: 1098752 B
uint64_t hbm103 = 0x0033d3c00; // storage size: 1098752 B
uint64_t hbm104 = 0x0034e0000; // storage size: 1096704 B
uint64_t hbm105 = 0x0035ebc00; // storage size: 207872 B
uint64_t hbm106 = 0x00361e800; // storage size: 29696 B
uint64_t hbm107 = 0x003625c00; // storage size: 29696 B
uint64_t hbm108 = 0x00362d000; // storage size: 207872 B
uint64_t hbm109 = 0x00365fc00; // storage size: 1098752 B
uint64_t hbm110 = 0x00376c000; // storage size: 1098752 B
uint64_t hbm111 = 0x003878400; // storage size: 1096704 B
uint64_t hbm112 = 0x003984000; // storage size: 207872 B
uint64_t hbm113 = 0x0039b6c00; // storage size: 29696 B
uint64_t hbm114 = 0x0039be000; // storage size: 29696 B
uint64_t hbm115 = 0x0039c5400; // storage size: 207872 B
uint64_t hbm116 = 0x0039f8000; // storage size: 1098752 B
uint64_t hbm117 = 0x003b04400; // storage size: 1098752 B
uint64_t hbm118 = 0x003c10800; // storage size: 1096704 B
uint64_t hbm119 = 0x003d1c400; // storage size: 207872 B
uint64_t hbm120 = 0x003d4f000; // storage size: 29696 B
uint64_t hbm121 = 0x003d56400; // storage size: 29696 B
uint64_t hbm122 = 0x003d5d800; // storage size: 207872 B
uint64_t hbm123 = 0x003d90400; // storage size: 1098752 B
uint64_t hbm124 = 0x003e9c800; // storage size: 1098752 B
uint64_t hbm125 = 0x003fa8c00; // storage size: 1096704 B
uint64_t hbm126 = 0x0040b4800; // storage size: 207872 B
uint64_t hbm127 = 0x0040e7400; // storage size: 29696 B
uint64_t hbm128 = 0x0040ee800; // storage size: 29696 B
uint64_t hbm129 = 0x0040f5c00; // storage size: 207872 B
uint64_t hbm130 = 0x004128800; // storage size: 1098752 B
uint64_t hbm131 = 0x004234c00; // storage size: 1098752 B
uint64_t hbm132 = 0x004341000; // storage size: 1096704 B
uint64_t hbm133 = 0x00444cc00; // storage size: 207872 B
uint64_t hbm134 = 0x00447f800; // storage size: 29696 B
uint64_t hbm135 = 0x004486c00; // storage size: 29696 B
uint64_t hbm136 = 0x00448e000; // storage size: 207872 B
uint64_t hbm137 = 0x0044c0c00; // storage size: 1098752 B
uint64_t hbm138 = 0x0045cd000; // storage size: 1098752 B
uint64_t hbm139 = 0x0046d9400; // storage size: 1096704 B
uint64_t hbm140 = 0x0047e5000; // storage size: 207872 B
uint64_t hbm141 = 0x004817c00; // storage size: 29696 B
uint64_t hbm142 = 0x00481f000; // storage size: 29696 B
uint64_t hbm143 = 0x004826400; // storage size: 207872 B
uint64_t hbm144 = 0x004859000; // storage size: 1098752 B
uint64_t hbm145 = 0x004965400; // storage size: 1098752 B
uint64_t hbm146 = 0x004a71800; // storage size: 1096704 B
uint64_t hbm147 = 0x004b7d400; // storage size: 207872 B
uint64_t hbm148 = 0x004bb0000; // storage size: 29696 B
uint64_t hbm149 = 0x004bb7400; // storage size: 29696 B
uint64_t hbm150 = 0x004bbe800; // storage size: 207872 B
uint64_t hbm151 = 0x004bf1400; // storage size: 1098752 B
uint64_t hbm152 = 0x004cfd800; // storage size: 1098752 B
uint64_t hbm153 = 0x004e09c00; // storage size: 1096704 B
uint64_t hbm154 = 0x004f15800; // storage size: 207872 B
uint64_t hbm155 = 0x004f48400; // storage size: 29696 B
uint64_t hbm156 = 0x004f4f800; // storage size: 29696 B
uint64_t hbm157 = 0x004f56c00; // storage size: 207872 B
uint64_t hbm158 = 0x004f89800; // storage size: 1098752 B
uint64_t hbm159 = 0x005095c00; // storage size: 1098752 B
uint64_t hbm160 = 0x0051a2000; // storage size: 1096704 B
uint64_t hbm161 = 0x0052adc00; // storage size: 207872 B
uint64_t hbm162 = 0x0052e0800; // storage size: 29696 B
uint64_t hbm163 = 0x0052e7c00; // storage size: 29696 B
uint64_t hbm164 = 0x0052ef000; // storage size: 207872 B
uint64_t hbm165 = 0x005321c00; // storage size: 1098752 B
uint64_t hbm166 = 0x00542e000; // storage size: 1098752 B
uint64_t hbm167 = 0x00553a400; // storage size: 1096704 B
uint64_t hbm168 = 0x005646000; // storage size: 207872 B
uint64_t hbm169 = 0x005678c00; // storage size: 29696 B
uint64_t hbm170 = 0x005680000; // storage size: 29696 B
uint64_t hbm171 = 0x005687400; // storage size: 207872 B
uint64_t hbm172 = 0x0056ba000; // storage size: 1098752 B
uint64_t hbm173 = 0x0057c6400; // storage size: 1098752 B
uint64_t hbm174 = 0x0058d2800; // storage size: 1096704 B
uint64_t hbm175 = 0x0059de400; // storage size: 207872 B
uint64_t hbm176 = 0x005a11000; // storage size: 29696 B
uint64_t hbm177 = 0x005a18400; // storage size: 29696 B
uint64_t hbm178 = 0x005a1f800; // storage size: 207872 B
uint64_t hbm179 = 0x005a52400; // storage size: 1098752 B
uint64_t hbm180 = 0x005b5e800; // storage size: 1098752 B
uint64_t hbm181 = 0x005c6ac00; // storage size: 1096704 B
uint64_t hbm182 = 0x005d76800; // storage size: 207872 B
uint64_t hbm183 = 0x005da9400; // storage size: 29696 B
uint64_t hbm184 = 0x005db0800; // storage size: 29696 B
uint64_t hbm185 = 0x005db7c00; // storage size: 207872 B
uint64_t hbm186 = 0x005dea800; // storage size: 1098752 B
uint64_t hbm187 = 0x005ef6c00; // storage size: 1098752 B
uint64_t hbm188 = 0x006003000; // storage size: 1096704 B
uint64_t hbm189 = 0x00610ec00; // storage size: 207872 B
uint64_t hbm190 = 0x006141800; // storage size: 29696 B
uint64_t hbm191 = 0x006148c00; // storage size: 29696 B
uint64_t hbm192 = 0x006150000; // storage size: 207872 B
uint64_t hbm193 = 0x006182c00; // storage size: 1098752 B
uint64_t hbm194 = 0x00628f000; // storage size: 1098752 B
uint64_t hbm195 = 0x00639b400; // storage size: 1096704 B
uint64_t hbm196 = 0x0064a7000; // storage size: 8819712 B
// hbm_cache storage define
uint64_t hbm_cache0 = 0x006d10400; // storage size: 65536 B
uint64_t hbm_cache1 = 0x006d20400; // storage size: 65536 B
uint64_t hbm_cache2 = 0x006d30400; // storage size: 65536 B
uint64_t hbm_cache3 = 0x006d40400; // storage size: 65536 B
uint64_t hbm_cache4 = 0x006d50400; // storage size: 65536 B
uint64_t hbm_cache5 = 0x006d60400; // storage size: 65536 B
uint64_t hbm_cache6 = 0x006d70400; // storage size: 65536 B
uint64_t hbm_cache7 = 0x006d80400; // storage size: 65536 B
uint64_t hbm_cache8 = 0x006d90400; // storage size: 65536 B
uint64_t hbm_cache9 = 0x006da0400; // storage size: 65536 B
uint64_t hbm_cache10 = 0x006db0400; // storage size: 65536 B
uint64_t hbm_cache11 = 0x006dc0400; // storage size: 65536 B
uint64_t hbm_cache12 = 0x006dd0400; // storage size: 65536 B
uint64_t hbm_cache13 = 0x006de0400; // storage size: 65536 B
uint64_t hbm_cache14 = 0x006df0400; // storage size: 65536 B
uint64_t hbm_cache15 = 0x006e00400; // storage size: 65536 B
uint64_t hbm_cache16 = 0x006e10400; // storage size: 65536 B
uint64_t hbm_cache17 = 0x006e20400; // storage size: 65536 B
uint64_t hbm_cache18 = 0x006e30400; // storage size: 65536 B
uint64_t hbm_cache19 = 0x006e40400; // storage size: 65536 B
uint64_t hbm_cache20 = 0x006e50400; // storage size: 65536 B
uint64_t hbm_cache21 = 0x006e60400; // storage size: 65536 B
uint64_t hbm_cache22 = 0x006e70400; // storage size: 65536 B
uint64_t hbm_cache23 = 0x006e80400; // storage size: 65536 B
uint64_t hbm_cache24 = 0x006e90400; // storage size: 65536 B
uint64_t hbm_cache25 = 0x006ea0400; // storage size: 65536 B
uint64_t hbm_cache26 = 0x006eb0400; // storage size: 65536 B
uint64_t hbm_cache27 = 0x006ec0400; // storage size: 65536 B
uint64_t hbm_cache28 = 0x006ed0400; // storage size: 65536 B
uint64_t hbm_cache29 = 0x006ee0400; // storage size: 65536 B
uint64_t hbm_cache30 = 0x006ef0400; // storage size: 65536 B
uint64_t hbm_cache31 = 0x006f00400; // storage size: 65536 B
uint64_t hbm_cache32 = 0x006f10400; // storage size: 65536 B
uint64_t hbm_cache33 = 0x006f20400; // storage size: 65536 B
uint64_t hbm_cache34 = 0x006f30400; // storage size: 65536 B
uint64_t hbm_cache35 = 0x006f40400; // storage size: 65536 B
uint64_t hbm_cache36 = 0x006f50400; // storage size: 65536 B
uint64_t hbm_cache37 = 0x006f60400; // storage size: 65536 B
uint64_t hbm_cache38 = 0x006f70400; // storage size: 65536 B
uint64_t hbm_cache39 = 0x006f80400; // storage size: 65536 B
uint64_t hbm_cache40 = 0x006f90400; // storage size: 65536 B
uint64_t hbm_cache41 = 0x006fa0400; // storage size: 65536 B
uint64_t hbm_cache42 = 0x006fb0400; // storage size: 65536 B
uint64_t hbm_cache43 = 0x006fc0400; // storage size: 65536 B
uint64_t hbm_cache44 = 0x006fd0400; // storage size: 65536 B
uint64_t hbm_cache45 = 0x006fe0400; // storage size: 65536 B
uint64_t hbm_cache46 = 0x006ff0400; // storage size: 65536 B
uint64_t hbm_cache47 = 0x007000400; // storage size: 65536 B
uint64_t hbm_cache48 = 0x007010400; // storage size: 65536 B
uint64_t hbm_cache49 = 0x007020400; // storage size: 65536 B
uint64_t hbm_cache50 = 0x007030400; // storage size: 65536 B
uint64_t hbm_cache51 = 0x007040400; // storage size: 65536 B
uint64_t hbm_cache52 = 0x007050400; // storage size: 65536 B
uint64_t hbm_cache53 = 0x007060400; // storage size: 65536 B
uint64_t hbm_cache54 = 0x007070400; // storage size: 65536 B
uint64_t hbm_cache55 = 0x007080400; // storage size: 65536 B

// get input ptr
uint64_t data_in = 0x20072c000; // ADDR_A

// get output ptr
uint64_t data_out = 0x23912c000; // 957530112

// get weight ddr ptr
uint64_t BLOCK00_ln_k_bias = 0x200082000; // 532480
uint64_t BLOCK00_q_bn_bias = 0x200085800; // 546816
uint64_t pos_emb = 0x200000000; // 0
uint64_t BLOCK00_k_bn_bias = 0x200089000; // 561152
uint64_t BLOCK00_v_bn_bias = 0x200089800; // 563200
uint64_t BLOCK00_atten_bn = 0x20008a000; // 565248
uint64_t BLOCK00_post_k_bias = 0x20008d800; // 579584
uint64_t BLOCK00_h_to_4h_bn_1 = 0x200091000; // 593920
uint64_t BLOCK00_h_to_4h_bn_0 = 0x2000a3800; // 669696
uint64_t silu_act = 0x200080000; // 524288
uint64_t BLOCK00_dense_4h_to_h_bn = 0x2000b6000; // 745472
uint64_t BLOCK01_ln_k_bias = 0x2000b9800; // 759808
uint64_t BLOCK01_q_bn_bias = 0x2000bd000; // 774144
uint64_t BLOCK01_k_bn_bias = 0x2000c0800; // 788480
uint64_t BLOCK01_v_bn_bias = 0x2000c1000; // 790528
uint64_t BLOCK01_atten_bn = 0x2000c1800; // 792576
uint64_t BLOCK01_post_k_bias = 0x2000c5000; // 806912
uint64_t BLOCK01_h_to_4h_bn_1 = 0x2000c8800; // 821248
uint64_t BLOCK01_h_to_4h_bn_0 = 0x2000db000; // 897024
uint64_t BLOCK01_dense_4h_to_h_bn = 0x2000ed800; // 972800
uint64_t BLOCK02_ln_k_bias = 0x2000f1000; // 987136
uint64_t BLOCK02_q_bn_bias = 0x2000f4800; // 1001472
uint64_t BLOCK02_k_bn_bias = 0x2000f8000; // 1015808
uint64_t BLOCK02_v_bn_bias = 0x2000f8800; // 1017856
uint64_t BLOCK02_atten_bn = 0x2000f9000; // 1019904
uint64_t BLOCK02_post_k_bias = 0x2000fc800; // 1034240
uint64_t BLOCK02_h_to_4h_bn_1 = 0x200100000; // 1048576
uint64_t BLOCK02_h_to_4h_bn_0 = 0x200112800; // 1124352
uint64_t BLOCK02_dense_4h_to_h_bn = 0x200125000; // 1200128
uint64_t BLOCK03_ln_k_bias = 0x200128800; // 1214464
uint64_t BLOCK03_q_bn_bias = 0x20012c000; // 1228800
uint64_t BLOCK03_k_bn_bias = 0x20012f800; // 1243136
uint64_t BLOCK03_v_bn_bias = 0x200130000; // 1245184
uint64_t BLOCK03_atten_bn = 0x200130800; // 1247232
uint64_t BLOCK03_post_k_bias = 0x200134000; // 1261568
uint64_t BLOCK03_h_to_4h_bn_1 = 0x200137800; // 1275904
uint64_t BLOCK03_h_to_4h_bn_0 = 0x20014a000; // 1351680
uint64_t BLOCK03_dense_4h_to_h_bn = 0x20015c800; // 1427456
uint64_t BLOCK04_ln_k_bias = 0x200160000; // 1441792
uint64_t BLOCK04_q_bn_bias = 0x200163800; // 1456128
uint64_t BLOCK04_k_bn_bias = 0x200167000; // 1470464
uint64_t BLOCK04_v_bn_bias = 0x200167800; // 1472512
uint64_t BLOCK04_atten_bn = 0x200168000; // 1474560
uint64_t BLOCK04_post_k_bias = 0x20016b800; // 1488896
uint64_t BLOCK04_h_to_4h_bn_1 = 0x20016f000; // 1503232
uint64_t BLOCK04_h_to_4h_bn_0 = 0x200181800; // 1579008
uint64_t BLOCK04_dense_4h_to_h_bn = 0x200194000; // 1654784
uint64_t BLOCK05_ln_k_bias = 0x200197800; // 1669120
uint64_t BLOCK05_q_bn_bias = 0x20019b000; // 1683456
uint64_t BLOCK05_k_bn_bias = 0x20019e800; // 1697792
uint64_t BLOCK05_v_bn_bias = 0x20019f000; // 1699840
uint64_t BLOCK05_atten_bn = 0x20019f800; // 1701888
uint64_t BLOCK05_post_k_bias = 0x2001a3000; // 1716224
uint64_t BLOCK05_h_to_4h_bn_1 = 0x2001a6800; // 1730560
uint64_t BLOCK05_h_to_4h_bn_0 = 0x2001b9000; // 1806336
uint64_t BLOCK05_dense_4h_to_h_bn = 0x2001cb800; // 1882112
uint64_t BLOCK06_ln_k_bias = 0x2001cf000; // 1896448
uint64_t BLOCK06_q_bn_bias = 0x2001d2800; // 1910784
uint64_t BLOCK06_k_bn_bias = 0x2001d6000; // 1925120
uint64_t BLOCK06_v_bn_bias = 0x2001d6800; // 1927168
uint64_t BLOCK06_atten_bn = 0x2001d7000; // 1929216
uint64_t BLOCK06_post_k_bias = 0x2001da800; // 1943552
uint64_t BLOCK06_h_to_4h_bn_1 = 0x2001de000; // 1957888
uint64_t BLOCK06_h_to_4h_bn_0 = 0x2001f0800; // 2033664
uint64_t BLOCK06_dense_4h_to_h_bn = 0x200203000; // 2109440
uint64_t BLOCK07_ln_k_bias = 0x200206800; // 2123776
uint64_t BLOCK07_q_bn_bias = 0x20020a000; // 2138112
uint64_t BLOCK07_k_bn_bias = 0x20020d800; // 2152448
uint64_t BLOCK07_v_bn_bias = 0x20020e000; // 2154496
uint64_t BLOCK07_atten_bn = 0x20020e800; // 2156544
uint64_t BLOCK07_post_k_bias = 0x200212000; // 2170880
uint64_t BLOCK07_h_to_4h_bn_1 = 0x200215800; // 2185216
uint64_t BLOCK07_h_to_4h_bn_0 = 0x200228000; // 2260992
uint64_t BLOCK07_dense_4h_to_h_bn = 0x20023a800; // 2336768
uint64_t BLOCK08_ln_k_bias = 0x20023e000; // 2351104
uint64_t BLOCK08_q_bn_bias = 0x200241800; // 2365440
uint64_t BLOCK08_k_bn_bias = 0x200245000; // 2379776
uint64_t BLOCK08_v_bn_bias = 0x200245800; // 2381824
uint64_t BLOCK08_atten_bn = 0x200246000; // 2383872
uint64_t BLOCK08_post_k_bias = 0x200249800; // 2398208
uint64_t BLOCK08_h_to_4h_bn_1 = 0x20024d000; // 2412544
uint64_t BLOCK08_h_to_4h_bn_0 = 0x20025f800; // 2488320
uint64_t BLOCK08_dense_4h_to_h_bn = 0x200272000; // 2564096
uint64_t BLOCK09_ln_k_bias = 0x200275800; // 2578432
uint64_t BLOCK09_q_bn_bias = 0x200279000; // 2592768
uint64_t BLOCK09_k_bn_bias = 0x20027c800; // 2607104
uint64_t BLOCK09_v_bn_bias = 0x20027d000; // 2609152
uint64_t BLOCK09_atten_bn = 0x20027d800; // 2611200
uint64_t BLOCK09_post_k_bias = 0x200281000; // 2625536
uint64_t BLOCK09_h_to_4h_bn_1 = 0x200284800; // 2639872
uint64_t BLOCK09_h_to_4h_bn_0 = 0x200297000; // 2715648
uint64_t BLOCK09_dense_4h_to_h_bn = 0x2002a9800; // 2791424
uint64_t BLOCK10_ln_k_bias = 0x2002ad000; // 2805760
uint64_t BLOCK10_q_bn_bias = 0x2002b0800; // 2820096
uint64_t BLOCK10_k_bn_bias = 0x2002b4000; // 2834432
uint64_t BLOCK10_v_bn_bias = 0x2002b4800; // 2836480
uint64_t BLOCK10_atten_bn = 0x2002b5000; // 2838528
uint64_t BLOCK10_post_k_bias = 0x2002b8800; // 2852864
uint64_t BLOCK10_h_to_4h_bn_1 = 0x2002bc000; // 2867200
uint64_t BLOCK10_h_to_4h_bn_0 = 0x2002ce800; // 2942976
uint64_t BLOCK10_dense_4h_to_h_bn = 0x2002e1000; // 3018752
uint64_t BLOCK11_ln_k_bias = 0x2002e4800; // 3033088
uint64_t BLOCK11_q_bn_bias = 0x2002e8000; // 3047424
uint64_t BLOCK11_k_bn_bias = 0x2002eb800; // 3061760
uint64_t BLOCK11_v_bn_bias = 0x2002ec000; // 3063808
uint64_t BLOCK11_atten_bn = 0x2002ec800; // 3065856
uint64_t BLOCK11_post_k_bias = 0x2002f0000; // 3080192
uint64_t BLOCK11_h_to_4h_bn_1 = 0x2002f3800; // 3094528
uint64_t BLOCK11_h_to_4h_bn_0 = 0x200306000; // 3170304
uint64_t BLOCK11_dense_4h_to_h_bn = 0x200318800; // 3246080
uint64_t BLOCK12_ln_k_bias = 0x20031c000; // 3260416
uint64_t BLOCK12_q_bn_bias = 0x20031f800; // 3274752
uint64_t BLOCK12_k_bn_bias = 0x200323000; // 3289088
uint64_t BLOCK12_v_bn_bias = 0x200323800; // 3291136
uint64_t BLOCK12_atten_bn = 0x200324000; // 3293184
uint64_t BLOCK12_post_k_bias = 0x200327800; // 3307520
uint64_t BLOCK12_h_to_4h_bn_1 = 0x20032b000; // 3321856
uint64_t BLOCK12_h_to_4h_bn_0 = 0x20033d800; // 3397632
uint64_t BLOCK12_dense_4h_to_h_bn = 0x200350000; // 3473408
uint64_t BLOCK13_ln_k_bias = 0x200353800; // 3487744
uint64_t BLOCK13_q_bn_bias = 0x200357000; // 3502080
uint64_t BLOCK13_k_bn_bias = 0x20035a800; // 3516416
uint64_t BLOCK13_v_bn_bias = 0x20035b000; // 3518464
uint64_t BLOCK13_atten_bn = 0x20035b800; // 3520512
uint64_t BLOCK13_post_k_bias = 0x20035f000; // 3534848
uint64_t BLOCK13_h_to_4h_bn_1 = 0x200362800; // 3549184
uint64_t BLOCK13_h_to_4h_bn_0 = 0x200375000; // 3624960
uint64_t BLOCK13_dense_4h_to_h_bn = 0x200387800; // 3700736
uint64_t BLOCK14_ln_k_bias = 0x20038b000; // 3715072
uint64_t BLOCK14_q_bn_bias = 0x20038e800; // 3729408
uint64_t BLOCK14_k_bn_bias = 0x200392000; // 3743744
uint64_t BLOCK14_v_bn_bias = 0x200392800; // 3745792
uint64_t BLOCK14_atten_bn = 0x200393000; // 3747840
uint64_t BLOCK14_post_k_bias = 0x200396800; // 3762176
uint64_t BLOCK14_h_to_4h_bn_1 = 0x20039a000; // 3776512
uint64_t BLOCK14_h_to_4h_bn_0 = 0x2003ac800; // 3852288
uint64_t BLOCK14_dense_4h_to_h_bn = 0x2003bf000; // 3928064
uint64_t BLOCK15_ln_k_bias = 0x2003c2800; // 3942400
uint64_t BLOCK15_q_bn_bias = 0x2003c6000; // 3956736
uint64_t BLOCK15_k_bn_bias = 0x2003c9800; // 3971072
uint64_t BLOCK15_v_bn_bias = 0x2003ca000; // 3973120
uint64_t BLOCK15_atten_bn = 0x2003ca800; // 3975168
uint64_t BLOCK15_post_k_bias = 0x2003ce000; // 3989504
uint64_t BLOCK15_h_to_4h_bn_1 = 0x2003d1800; // 4003840
uint64_t BLOCK15_h_to_4h_bn_0 = 0x2003e4000; // 4079616
uint64_t BLOCK15_dense_4h_to_h_bn = 0x2003f6800; // 4155392
uint64_t BLOCK16_ln_k_bias = 0x2003fa000; // 4169728
uint64_t BLOCK16_q_bn_bias = 0x2003fd800; // 4184064
uint64_t BLOCK16_k_bn_bias = 0x200401000; // 4198400
uint64_t BLOCK16_v_bn_bias = 0x200401800; // 4200448
uint64_t BLOCK16_atten_bn = 0x200402000; // 4202496
uint64_t BLOCK16_post_k_bias = 0x200405800; // 4216832
uint64_t BLOCK16_h_to_4h_bn_1 = 0x200409000; // 4231168
uint64_t BLOCK16_h_to_4h_bn_0 = 0x20041b800; // 4306944
uint64_t BLOCK16_dense_4h_to_h_bn = 0x20042e000; // 4382720
uint64_t BLOCK17_ln_k_bias = 0x200431800; // 4397056
uint64_t BLOCK17_q_bn_bias = 0x200435000; // 4411392
uint64_t BLOCK17_k_bn_bias = 0x200438800; // 4425728
uint64_t BLOCK17_v_bn_bias = 0x200439000; // 4427776
uint64_t BLOCK17_atten_bn = 0x200439800; // 4429824
uint64_t BLOCK17_post_k_bias = 0x20043d000; // 4444160
uint64_t BLOCK17_h_to_4h_bn_1 = 0x200440800; // 4458496
uint64_t BLOCK17_h_to_4h_bn_0 = 0x200453000; // 4534272
uint64_t BLOCK17_dense_4h_to_h_bn = 0x200465800; // 4610048
uint64_t BLOCK18_ln_k_bias = 0x200469000; // 4624384
uint64_t BLOCK18_q_bn_bias = 0x20046c800; // 4638720
uint64_t BLOCK18_k_bn_bias = 0x200470000; // 4653056
uint64_t BLOCK18_v_bn_bias = 0x200470800; // 4655104
uint64_t BLOCK18_atten_bn = 0x200471000; // 4657152
uint64_t BLOCK18_post_k_bias = 0x200474800; // 4671488
uint64_t BLOCK18_h_to_4h_bn_1 = 0x200478000; // 4685824
uint64_t BLOCK18_h_to_4h_bn_0 = 0x20048a800; // 4761600
uint64_t BLOCK18_dense_4h_to_h_bn = 0x20049d000; // 4837376
uint64_t BLOCK19_ln_k_bias = 0x2004a0800; // 4851712
uint64_t BLOCK19_q_bn_bias = 0x2004a4000; // 4866048
uint64_t BLOCK19_k_bn_bias = 0x2004a7800; // 4880384
uint64_t BLOCK19_v_bn_bias = 0x2004a8000; // 4882432
uint64_t BLOCK19_atten_bn = 0x2004a8800; // 4884480
uint64_t BLOCK19_post_k_bias = 0x2004ac000; // 4898816
uint64_t BLOCK19_h_to_4h_bn_1 = 0x2004af800; // 4913152
uint64_t BLOCK19_h_to_4h_bn_0 = 0x2004c2000; // 4988928
uint64_t BLOCK19_dense_4h_to_h_bn = 0x2004d4800; // 5064704
uint64_t BLOCK20_ln_k_bias = 0x2004d8000; // 5079040
uint64_t BLOCK20_q_bn_bias = 0x2004db800; // 5093376
uint64_t BLOCK20_k_bn_bias = 0x2004df000; // 5107712
uint64_t BLOCK20_v_bn_bias = 0x2004df800; // 5109760
uint64_t BLOCK20_atten_bn = 0x2004e0000; // 5111808
uint64_t BLOCK20_post_k_bias = 0x2004e3800; // 5126144
uint64_t BLOCK20_h_to_4h_bn_1 = 0x2004e7000; // 5140480
uint64_t BLOCK20_h_to_4h_bn_0 = 0x2004f9800; // 5216256
uint64_t BLOCK20_dense_4h_to_h_bn = 0x20050c000; // 5292032
uint64_t BLOCK21_ln_k_bias = 0x20050f800; // 5306368
uint64_t BLOCK21_q_bn_bias = 0x200513000; // 5320704
uint64_t BLOCK21_k_bn_bias = 0x200516800; // 5335040
uint64_t BLOCK21_v_bn_bias = 0x200517000; // 5337088
uint64_t BLOCK21_atten_bn = 0x200517800; // 5339136
uint64_t BLOCK21_post_k_bias = 0x20051b000; // 5353472
uint64_t BLOCK21_h_to_4h_bn_1 = 0x20051e800; // 5367808
uint64_t BLOCK21_h_to_4h_bn_0 = 0x200531000; // 5443584
uint64_t BLOCK21_dense_4h_to_h_bn = 0x200543800; // 5519360
uint64_t BLOCK22_ln_k_bias = 0x200547000; // 5533696
uint64_t BLOCK22_q_bn_bias = 0x20054a800; // 5548032
uint64_t BLOCK22_k_bn_bias = 0x20054e000; // 5562368
uint64_t BLOCK22_v_bn_bias = 0x20054e800; // 5564416
uint64_t BLOCK22_atten_bn = 0x20054f000; // 5566464
uint64_t BLOCK22_post_k_bias = 0x200552800; // 5580800
uint64_t BLOCK22_h_to_4h_bn_1 = 0x200556000; // 5595136
uint64_t BLOCK22_h_to_4h_bn_0 = 0x200568800; // 5670912
uint64_t BLOCK22_dense_4h_to_h_bn = 0x20057b000; // 5746688
uint64_t BLOCK23_ln_k_bias = 0x20057e800; // 5761024
uint64_t BLOCK23_q_bn_bias = 0x200582000; // 5775360
uint64_t BLOCK23_k_bn_bias = 0x200585800; // 5789696
uint64_t BLOCK23_v_bn_bias = 0x200586000; // 5791744
uint64_t BLOCK23_atten_bn = 0x200586800; // 5793792
uint64_t BLOCK23_post_k_bias = 0x20058a000; // 5808128
uint64_t BLOCK23_h_to_4h_bn_1 = 0x20058d800; // 5822464
uint64_t BLOCK23_h_to_4h_bn_0 = 0x2005a0000; // 5898240
uint64_t BLOCK23_dense_4h_to_h_bn = 0x2005b2800; // 5974016
uint64_t BLOCK24_ln_k_bias = 0x2005b6000; // 5988352
uint64_t BLOCK24_q_bn_bias = 0x2005b9800; // 6002688
uint64_t BLOCK24_k_bn_bias = 0x2005bd000; // 6017024
uint64_t BLOCK24_v_bn_bias = 0x2005bd800; // 6019072
uint64_t BLOCK24_atten_bn = 0x2005be000; // 6021120
uint64_t BLOCK24_post_k_bias = 0x2005c1800; // 6035456
uint64_t BLOCK24_h_to_4h_bn_1 = 0x2005c5000; // 6049792
uint64_t BLOCK24_h_to_4h_bn_0 = 0x2005d7800; // 6125568
uint64_t BLOCK24_dense_4h_to_h_bn = 0x2005ea000; // 6201344
uint64_t BLOCK25_ln_k_bias = 0x2005ed800; // 6215680
uint64_t BLOCK25_q_bn_bias = 0x2005f1000; // 6230016
uint64_t BLOCK25_k_bn_bias = 0x2005f4800; // 6244352
uint64_t BLOCK25_v_bn_bias = 0x2005f5000; // 6246400
uint64_t BLOCK25_atten_bn = 0x2005f5800; // 6248448
uint64_t BLOCK25_post_k_bias = 0x2005f9000; // 6262784
uint64_t BLOCK25_h_to_4h_bn_1 = 0x2005fc800; // 6277120
uint64_t BLOCK25_h_to_4h_bn_0 = 0x20060f000; // 6352896
uint64_t BLOCK25_dense_4h_to_h_bn = 0x200621800; // 6428672
uint64_t BLOCK26_ln_k_bias = 0x200625000; // 6443008
uint64_t BLOCK26_q_bn_bias = 0x200628800; // 6457344
uint64_t BLOCK26_k_bn_bias = 0x20062c000; // 6471680
uint64_t BLOCK26_v_bn_bias = 0x20062c800; // 6473728
uint64_t BLOCK26_atten_bn = 0x20062d000; // 6475776
uint64_t BLOCK26_post_k_bias = 0x200630800; // 6490112
uint64_t BLOCK26_h_to_4h_bn_1 = 0x200634000; // 6504448
uint64_t BLOCK26_h_to_4h_bn_0 = 0x200646800; // 6580224
uint64_t BLOCK26_dense_4h_to_h_bn = 0x200659000; // 6656000
uint64_t BLOCK27_ln_k_bias = 0x20065c800; // 6670336
uint64_t BLOCK27_q_bn_bias = 0x200660000; // 6684672
uint64_t BLOCK27_k_bn_bias = 0x200663800; // 6699008
uint64_t BLOCK27_v_bn_bias = 0x200664000; // 6701056
uint64_t BLOCK27_atten_bn = 0x200664800; // 6703104
uint64_t BLOCK27_post_k_bias = 0x200668000; // 6717440
uint64_t BLOCK27_h_to_4h_bn_1 = 0x20066b800; // 6731776
uint64_t BLOCK27_h_to_4h_bn_0 = 0x20067e000; // 6807552
uint64_t BLOCK27_dense_4h_to_h_bn = 0x200690800; // 6883328
uint64_t Final_LN_k_bias = 0x200694000; // 6897664
uint64_t Output_Layer_bn = 0x200697800; // 6912000

// get weight hbm ptr
uint64_t BLOCK00_q_weight = 0x000000000; // 0
uint64_t BLOCK00_k_weight = 0x000032c00; // 207872
uint64_t BLOCK00_v_weight = 0x00003a000; // 237568
uint64_t BLOCK00_atten_weight = 0x000041400; // 267264
uint64_t BLOCK00_h_to_4h_wt_1 = 0x000074000; // 475136
uint64_t BLOCK00_h_to_4h_wt_0 = 0x000180400; // 1573888
uint64_t BLOCK00_dense_4h_to_h_wt = 0x00028c800; // 2672640
uint64_t BLOCK01_q_weight = 0x000398400; // 3769344
uint64_t BLOCK01_k_weight = 0x0003cb000; // 3977216
uint64_t BLOCK01_v_weight = 0x0003d2400; // 4006912
uint64_t BLOCK01_atten_weight = 0x0003d9800; // 4036608
uint64_t BLOCK01_h_to_4h_wt_1 = 0x00040c400; // 4244480
uint64_t BLOCK01_h_to_4h_wt_0 = 0x000518800; // 5343232
uint64_t BLOCK01_dense_4h_to_h_wt = 0x000624c00; // 6441984
uint64_t BLOCK02_q_weight = 0x000730800; // 7538688
uint64_t BLOCK02_k_weight = 0x000763400; // 7746560
uint64_t BLOCK02_v_weight = 0x00076a800; // 7776256
uint64_t BLOCK02_atten_weight = 0x000771c00; // 7805952
uint64_t BLOCK02_h_to_4h_wt_1 = 0x0007a4800; // 8013824
uint64_t BLOCK02_h_to_4h_wt_0 = 0x0008b0c00; // 9112576
uint64_t BLOCK02_dense_4h_to_h_wt = 0x0009bd000; // 10211328
uint64_t BLOCK03_q_weight = 0x000ac8c00; // 11308032
uint64_t BLOCK03_k_weight = 0x000afb800; // 11515904
uint64_t BLOCK03_v_weight = 0x000b02c00; // 11545600
uint64_t BLOCK03_atten_weight = 0x000b0a000; // 11575296
uint64_t BLOCK03_h_to_4h_wt_1 = 0x000b3cc00; // 11783168
uint64_t BLOCK03_h_to_4h_wt_0 = 0x000c49000; // 12881920
uint64_t BLOCK03_dense_4h_to_h_wt = 0x000d55400; // 13980672
uint64_t BLOCK04_q_weight = 0x000e61000; // 15077376
uint64_t BLOCK04_k_weight = 0x000e93c00; // 15285248
uint64_t BLOCK04_v_weight = 0x000e9b000; // 15314944
uint64_t BLOCK04_atten_weight = 0x000ea2400; // 15344640
uint64_t BLOCK04_h_to_4h_wt_1 = 0x000ed5000; // 15552512
uint64_t BLOCK04_h_to_4h_wt_0 = 0x000fe1400; // 16651264
uint64_t BLOCK04_dense_4h_to_h_wt = 0x0010ed800; // 17750016
uint64_t BLOCK05_q_weight = 0x0011f9400; // 18846720
uint64_t BLOCK05_k_weight = 0x00122c000; // 19054592
uint64_t BLOCK05_v_weight = 0x001233400; // 19084288
uint64_t BLOCK05_atten_weight = 0x00123a800; // 19113984
uint64_t BLOCK05_h_to_4h_wt_1 = 0x00126d400; // 19321856
uint64_t BLOCK05_h_to_4h_wt_0 = 0x001379800; // 20420608
uint64_t BLOCK05_dense_4h_to_h_wt = 0x001485c00; // 21519360
uint64_t BLOCK06_q_weight = 0x001591800; // 22616064
uint64_t BLOCK06_k_weight = 0x0015c4400; // 22823936
uint64_t BLOCK06_v_weight = 0x0015cb800; // 22853632
uint64_t BLOCK06_atten_weight = 0x0015d2c00; // 22883328
uint64_t BLOCK06_h_to_4h_wt_1 = 0x001605800; // 23091200
uint64_t BLOCK06_h_to_4h_wt_0 = 0x001711c00; // 24189952
uint64_t BLOCK06_dense_4h_to_h_wt = 0x00181e000; // 25288704
uint64_t BLOCK07_q_weight = 0x001929c00; // 26385408
uint64_t BLOCK07_k_weight = 0x00195c800; // 26593280
uint64_t BLOCK07_v_weight = 0x001963c00; // 26622976
uint64_t BLOCK07_atten_weight = 0x00196b000; // 26652672
uint64_t BLOCK07_h_to_4h_wt_1 = 0x00199dc00; // 26860544
uint64_t BLOCK07_h_to_4h_wt_0 = 0x001aaa000; // 27959296
uint64_t BLOCK07_dense_4h_to_h_wt = 0x001bb6400; // 29058048
uint64_t BLOCK08_q_weight = 0x001cc2000; // 30154752
uint64_t BLOCK08_k_weight = 0x001cf4c00; // 30362624
uint64_t BLOCK08_v_weight = 0x001cfc000; // 30392320
uint64_t BLOCK08_atten_weight = 0x001d03400; // 30422016
uint64_t BLOCK08_h_to_4h_wt_1 = 0x001d36000; // 30629888
uint64_t BLOCK08_h_to_4h_wt_0 = 0x001e42400; // 31728640
uint64_t BLOCK08_dense_4h_to_h_wt = 0x001f4e800; // 32827392
uint64_t BLOCK09_q_weight = 0x00205a400; // 33924096
uint64_t BLOCK09_k_weight = 0x00208d000; // 34131968
uint64_t BLOCK09_v_weight = 0x002094400; // 34161664
uint64_t BLOCK09_atten_weight = 0x00209b800; // 34191360
uint64_t BLOCK09_h_to_4h_wt_1 = 0x0020ce400; // 34399232
uint64_t BLOCK09_h_to_4h_wt_0 = 0x0021da800; // 35497984
uint64_t BLOCK09_dense_4h_to_h_wt = 0x0022e6c00; // 36596736
uint64_t BLOCK10_q_weight = 0x0023f2800; // 37693440
uint64_t BLOCK10_k_weight = 0x002425400; // 37901312
uint64_t BLOCK10_v_weight = 0x00242c800; // 37931008
uint64_t BLOCK10_atten_weight = 0x002433c00; // 37960704
uint64_t BLOCK10_h_to_4h_wt_1 = 0x002466800; // 38168576
uint64_t BLOCK10_h_to_4h_wt_0 = 0x002572c00; // 39267328
uint64_t BLOCK10_dense_4h_to_h_wt = 0x00267f000; // 40366080
uint64_t BLOCK11_q_weight = 0x00278ac00; // 41462784
uint64_t BLOCK11_k_weight = 0x0027bd800; // 41670656
uint64_t BLOCK11_v_weight = 0x0027c4c00; // 41700352
uint64_t BLOCK11_atten_weight = 0x0027cc000; // 41730048
uint64_t BLOCK11_h_to_4h_wt_1 = 0x0027fec00; // 41937920
uint64_t BLOCK11_h_to_4h_wt_0 = 0x00290b000; // 43036672
uint64_t BLOCK11_dense_4h_to_h_wt = 0x002a17400; // 44135424
uint64_t BLOCK12_q_weight = 0x002b23000; // 45232128
uint64_t BLOCK12_k_weight = 0x002b55c00; // 45440000
uint64_t BLOCK12_v_weight = 0x002b5d000; // 45469696
uint64_t BLOCK12_atten_weight = 0x002b64400; // 45499392
uint64_t BLOCK12_h_to_4h_wt_1 = 0x002b97000; // 45707264
uint64_t BLOCK12_h_to_4h_wt_0 = 0x002ca3400; // 46806016
uint64_t BLOCK12_dense_4h_to_h_wt = 0x002daf800; // 47904768
uint64_t BLOCK13_q_weight = 0x002ebb400; // 49001472
uint64_t BLOCK13_k_weight = 0x002eee000; // 49209344
uint64_t BLOCK13_v_weight = 0x002ef5400; // 49239040
uint64_t BLOCK13_atten_weight = 0x002efc800; // 49268736
uint64_t BLOCK13_h_to_4h_wt_1 = 0x002f2f400; // 49476608
uint64_t BLOCK13_h_to_4h_wt_0 = 0x00303b800; // 50575360
uint64_t BLOCK13_dense_4h_to_h_wt = 0x003147c00; // 51674112
uint64_t BLOCK14_q_weight = 0x003253800; // 52770816
uint64_t BLOCK14_k_weight = 0x003286400; // 52978688
uint64_t BLOCK14_v_weight = 0x00328d800; // 53008384
uint64_t BLOCK14_atten_weight = 0x003294c00; // 53038080
uint64_t BLOCK14_h_to_4h_wt_1 = 0x0032c7800; // 53245952
uint64_t BLOCK14_h_to_4h_wt_0 = 0x0033d3c00; // 54344704
uint64_t BLOCK14_dense_4h_to_h_wt = 0x0034e0000; // 55443456
uint64_t BLOCK15_q_weight = 0x0035ebc00; // 56540160
uint64_t BLOCK15_k_weight = 0x00361e800; // 56748032
uint64_t BLOCK15_v_weight = 0x003625c00; // 56777728
uint64_t BLOCK15_atten_weight = 0x00362d000; // 56807424
uint64_t BLOCK15_h_to_4h_wt_1 = 0x00365fc00; // 57015296
uint64_t BLOCK15_h_to_4h_wt_0 = 0x00376c000; // 58114048
uint64_t BLOCK15_dense_4h_to_h_wt = 0x003878400; // 59212800
uint64_t BLOCK16_q_weight = 0x003984000; // 60309504
uint64_t BLOCK16_k_weight = 0x0039b6c00; // 60517376
uint64_t BLOCK16_v_weight = 0x0039be000; // 60547072
uint64_t BLOCK16_atten_weight = 0x0039c5400; // 60576768
uint64_t BLOCK16_h_to_4h_wt_1 = 0x0039f8000; // 60784640
uint64_t BLOCK16_h_to_4h_wt_0 = 0x003b04400; // 61883392
uint64_t BLOCK16_dense_4h_to_h_wt = 0x003c10800; // 62982144
uint64_t BLOCK17_q_weight = 0x003d1c400; // 64078848
uint64_t BLOCK17_k_weight = 0x003d4f000; // 64286720
uint64_t BLOCK17_v_weight = 0x003d56400; // 64316416
uint64_t BLOCK17_atten_weight = 0x003d5d800; // 64346112
uint64_t BLOCK17_h_to_4h_wt_1 = 0x003d90400; // 64553984
uint64_t BLOCK17_h_to_4h_wt_0 = 0x003e9c800; // 65652736
uint64_t BLOCK17_dense_4h_to_h_wt = 0x003fa8c00; // 66751488
uint64_t BLOCK18_q_weight = 0x0040b4800; // 67848192
uint64_t BLOCK18_k_weight = 0x0040e7400; // 68056064
uint64_t BLOCK18_v_weight = 0x0040ee800; // 68085760
uint64_t BLOCK18_atten_weight = 0x0040f5c00; // 68115456
uint64_t BLOCK18_h_to_4h_wt_1 = 0x004128800; // 68323328
uint64_t BLOCK18_h_to_4h_wt_0 = 0x004234c00; // 69422080
uint64_t BLOCK18_dense_4h_to_h_wt = 0x004341000; // 70520832
uint64_t BLOCK19_q_weight = 0x00444cc00; // 71617536
uint64_t BLOCK19_k_weight = 0x00447f800; // 71825408
uint64_t BLOCK19_v_weight = 0x004486c00; // 71855104
uint64_t BLOCK19_atten_weight = 0x00448e000; // 71884800
uint64_t BLOCK19_h_to_4h_wt_1 = 0x0044c0c00; // 72092672
uint64_t BLOCK19_h_to_4h_wt_0 = 0x0045cd000; // 73191424
uint64_t BLOCK19_dense_4h_to_h_wt = 0x0046d9400; // 74290176
uint64_t BLOCK20_q_weight = 0x0047e5000; // 75386880
uint64_t BLOCK20_k_weight = 0x004817c00; // 75594752
uint64_t BLOCK20_v_weight = 0x00481f000; // 75624448
uint64_t BLOCK20_atten_weight = 0x004826400; // 75654144
uint64_t BLOCK20_h_to_4h_wt_1 = 0x004859000; // 75862016
uint64_t BLOCK20_h_to_4h_wt_0 = 0x004965400; // 76960768
uint64_t BLOCK20_dense_4h_to_h_wt = 0x004a71800; // 78059520
uint64_t BLOCK21_q_weight = 0x004b7d400; // 79156224
uint64_t BLOCK21_k_weight = 0x004bb0000; // 79364096
uint64_t BLOCK21_v_weight = 0x004bb7400; // 79393792
uint64_t BLOCK21_atten_weight = 0x004bbe800; // 79423488
uint64_t BLOCK21_h_to_4h_wt_1 = 0x004bf1400; // 79631360
uint64_t BLOCK21_h_to_4h_wt_0 = 0x004cfd800; // 80730112
uint64_t BLOCK21_dense_4h_to_h_wt = 0x004e09c00; // 81828864
uint64_t BLOCK22_q_weight = 0x004f15800; // 82925568
uint64_t BLOCK22_k_weight = 0x004f48400; // 83133440
uint64_t BLOCK22_v_weight = 0x004f4f800; // 83163136
uint64_t BLOCK22_atten_weight = 0x004f56c00; // 83192832
uint64_t BLOCK22_h_to_4h_wt_1 = 0x004f89800; // 83400704
uint64_t BLOCK22_h_to_4h_wt_0 = 0x005095c00; // 84499456
uint64_t BLOCK22_dense_4h_to_h_wt = 0x0051a2000; // 85598208
uint64_t BLOCK23_q_weight = 0x0052adc00; // 86694912
uint64_t BLOCK23_k_weight = 0x0052e0800; // 86902784
uint64_t BLOCK23_v_weight = 0x0052e7c00; // 86932480
uint64_t BLOCK23_atten_weight = 0x0052ef000; // 86962176
uint64_t BLOCK23_h_to_4h_wt_1 = 0x005321c00; // 87170048
uint64_t BLOCK23_h_to_4h_wt_0 = 0x00542e000; // 88268800
uint64_t BLOCK23_dense_4h_to_h_wt = 0x00553a400; // 89367552
uint64_t BLOCK24_q_weight = 0x005646000; // 90464256
uint64_t BLOCK24_k_weight = 0x005678c00; // 90672128
uint64_t BLOCK24_v_weight = 0x005680000; // 90701824
uint64_t BLOCK24_atten_weight = 0x005687400; // 90731520
uint64_t BLOCK24_h_to_4h_wt_1 = 0x0056ba000; // 90939392
uint64_t BLOCK24_h_to_4h_wt_0 = 0x0057c6400; // 92038144
uint64_t BLOCK24_dense_4h_to_h_wt = 0x0058d2800; // 93136896
uint64_t BLOCK25_q_weight = 0x0059de400; // 94233600
uint64_t BLOCK25_k_weight = 0x005a11000; // 94441472
uint64_t BLOCK25_v_weight = 0x005a18400; // 94471168
uint64_t BLOCK25_atten_weight = 0x005a1f800; // 94500864
uint64_t BLOCK25_h_to_4h_wt_1 = 0x005a52400; // 94708736
uint64_t BLOCK25_h_to_4h_wt_0 = 0x005b5e800; // 95807488
uint64_t BLOCK25_dense_4h_to_h_wt = 0x005c6ac00; // 96906240
uint64_t BLOCK26_q_weight = 0x005d76800; // 98002944
uint64_t BLOCK26_k_weight = 0x005da9400; // 98210816
uint64_t BLOCK26_v_weight = 0x005db0800; // 98240512
uint64_t BLOCK26_atten_weight = 0x005db7c00; // 98270208
uint64_t BLOCK26_h_to_4h_wt_1 = 0x005dea800; // 98478080
uint64_t BLOCK26_h_to_4h_wt_0 = 0x005ef6c00; // 99576832
uint64_t BLOCK26_dense_4h_to_h_wt = 0x006003000; // 100675584
uint64_t BLOCK27_q_weight = 0x00610ec00; // 101772288
uint64_t BLOCK27_k_weight = 0x006141800; // 101980160
uint64_t BLOCK27_v_weight = 0x006148c00; // 102009856
uint64_t BLOCK27_atten_weight = 0x006150000; // 102039552
uint64_t BLOCK27_h_to_4h_wt_1 = 0x006182c00; // 102247424
uint64_t BLOCK27_h_to_4h_wt_0 = 0x00628f000; // 103346176
uint64_t BLOCK27_dense_4h_to_h_wt = 0x00639b400; // 104444928
uint64_t Output_Layer_wt = 0x0064a7000; // 105541632

//#define PRINT_STEP

void step1 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.layer_norm accel operator node, storage data in runtime1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 532480);
  CSB_Write(device, 195, ADDR_A);
  CSB_Write(device, 196, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_B);
  CSB_Write(device, 199, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, 112);
  CSB_Write(device, 202, 1);
  CSB_Write(device, 203, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 204, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 205, 156818);
  CSB_Write(device, 206, 7);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 32);
#ifdef PRINT_STEP
printf("start: step1!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.layer_norm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step2 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime3 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 1024);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_B + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 0);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_C + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 3);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 546816);
    CSB_Write(device, 27, 0);
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 799);
    #ifdef PRINT_STEP
    printf("start: step2!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step3 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.pos_emb accel operator node, storage data in runtime3 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, (kvcache ? ((token - 1) * 64) : (last_token * 64)));
  CSB_Write(device, 195, ADDR_C);
  CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_D);
  CSB_Write(device, 199, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, 4);
  CSB_Write(device, 202, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 203, last_token);
  CSB_Write(device, 204, 28);
  CSB_Write(device, 205, 262144);
  CSB_Write(device, 206, 131072);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 4);
#ifdef PRINT_STEP
printf("start: step3!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.pos_emb run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step4 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime4 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 512);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_B + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 207872);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_C + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 0);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 561152);
    CSB_Write(device, 27, 0);
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 799);
    #ifdef PRINT_STEP
    printf("start: step4!\n");
    #endif	
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step5 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.pos_emb accel operator node, storage data in runtime4 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, (kvcache ? ((token - 1) * 64) : (last_token * 64)));
  CSB_Write(device, 195, ADDR_C);
  CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_E);
  CSB_Write(device, 199, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, 4);
  CSB_Write(device, 202, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 203, last_token);
  CSB_Write(device, 204, 4);
  CSB_Write(device, 205, 262144);
  CSB_Write(device, 206, 131072);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 4);
#ifdef PRINT_STEP
printf("start: step5!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.pos_emb run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step6 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.dat2hbm accel operator node, storage data in hbm_cache0 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 0);
  CSB_Write(device, 195, ADDR_E);
  CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, 114361344);
  CSB_Write(device, 199, 524288);
  CSB_Write(device, 200, 131072);
  CSB_Write(device, 201, 28);
  CSB_Write(device, 202, last_token);
  CSB_Write(device, 203, (token - last_token));
  CSB_Write(device, 204, 4);
  CSB_Write(device, 205, 4);
  CSB_Write(device, 206, 1);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 64);
#ifdef PRINT_STEP
printf("start: step6!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.dat2hbm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step7 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.trp_mvm accel operator node, storage data in runtime3 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = ((((seq + 292) - 1) / 292) - 1);
  int out_w_slice_last = (seq - (((((seq + 292) - 1) / 292) - 1) * 292));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 194, 114361344);
    CSB_Write(device, 195, (ADDR_D + ((out_w * 292) * 64)));
    CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
    CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
    CSB_Write(device, 198, (ADDR_C + ((out_w * 292) * 64)));
    CSB_Write(device, 199, ((64 * (kvcache ? 1 : (token - last_token))) * (((token + 32) - 1) / 32)));
    CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
    CSB_Write(device, 201, 524288);
    CSB_Write(device, 202, 131072);
    CSB_Write(device, 203, 128);
    CSB_Write(device, 204, token);
    CSB_Write(device, 205, ((out_w < wout_split_times_minus1) ? 292 : out_w_slice_last));
    CSB_Write(device, 206, 29584705);
    CSB_Write(device, 207, 400388);
    CSB_Write(device, 208, 0);
    CSB_Write(device, 209, 2);
    #ifdef PRINT_STEP
    printf("start: step7!\n");
    #endif
    while(CSB_Read(device, 193) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.trp_mvm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step8 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.softmax accel operator node, storage data in runtime3 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, (1 - kvcache));
  CSB_Write(device, 195, ADDR_C);
  CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * (((token + 32) - 1) / 32)));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_D);
  CSB_Write(device, 199, ((64 * (kvcache ? 1 : (token - last_token))) * (((token + 32) - 1) / 32)));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, (((token + 32) - 1) / 32));
  CSB_Write(device, 202, 28);
  CSB_Write(device, 203, token);
  CSB_Write(device, 204, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 205, (token - last_token));
  CSB_Write(device, 206, last_token);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 8);
#ifdef PRINT_STEP
printf("start: step8!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.softmax run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step9 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime4 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 512);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_B + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 237568);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_E + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 0);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 563200);
    CSB_Write(device, 27, 0);
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 799);
    #ifdef PRINT_STEP
    printf("start: step9!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step10 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.dat2hbm accel operator node, storage data in hbm_cache1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 0);
  CSB_Write(device, 195, ADDR_E);
  CSB_Write(device, 196, ((64 * (kvcache ? 1 : (token - last_token))) * 4));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, 114426880);
  CSB_Write(device, 199, 524288);
  CSB_Write(device, 200, 131072);
  CSB_Write(device, 201, 28);
  CSB_Write(device, 202, last_token);
  CSB_Write(device, 203, (token - last_token));
  CSB_Write(device, 204, 4);
  CSB_Write(device, 205, 4);
  CSB_Write(device, 206, 0);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 64);
#ifdef PRINT_STEP
printf("start: step10!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.dat2hbm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step11 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.f2w_mvm accel operator node, storage data in runtime1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int out_w_per_slice = (4194304 / ((((((token + 32) - 1) / 32) * 32) * 7) * 16));
  int wout_split_times_minus1 = ((((seq + out_w_per_slice) - 1) / out_w_per_slice) - 1);
  int out_w_slice_last = (seq - (((((seq + out_w_per_slice) - 1) / out_w_per_slice) - 1) * out_w_per_slice));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 194, 114426880);
    CSB_Write(device, 195, (ADDR_D + ((out_w * out_w_per_slice) * 64)));
    CSB_Write(device, 196, (((((token + 32) - 1) / 32) * seq) * 64));
    CSB_Write(device, 197, (seq * 64));
    CSB_Write(device, 198, (ADDR_B + ((out_w * out_w_per_slice) * 64)));
    CSB_Write(device, 199, ((4 * seq) * 64));
    CSB_Write(device, 200, (seq * 64));
    CSB_Write(device, 201, 524288);
    CSB_Write(device, 202, 131072);
    CSB_Write(device, 203, 128);
    CSB_Write(device, 204, token);
    CSB_Write(device, 205, ((out_w < wout_split_times_minus1) ? out_w_per_slice : out_w_slice_last));
    CSB_Write(device, 206, 29614080);
    CSB_Write(device, 207, 400388);
    CSB_Write(device, 208, 0);
    CSB_Write(device, 209, 1);
    #ifdef PRINT_STEP
    printf("start: step11!\n");
    #endif
    while(CSB_Read(device, 193) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.f2w_mvm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step12 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn_res accel operator node, storage data in runtime2 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 1024);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_B  + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 267264);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_D + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 3);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 565248);
    CSB_Write(device, 27, ADDR_A + ((out_w * 146) * 64));
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 1823);
    #ifdef PRINT_STEP
    printf("start: step12!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn_res run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step13 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.layer_norm accel operator node, storage data in runtime0 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 579584);
  CSB_Write(device, 195, ADDR_D);
  CSB_Write(device, 196, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_A);
  CSB_Write(device, 199, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, 112);
  CSB_Write(device, 202, 1);
  CSB_Write(device, 203, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 204, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 205, 156818);
  CSB_Write(device, 206, 7);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 32);
#ifdef PRINT_STEP
printf("start: step13!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.layer_norm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step14 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 1024);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_A + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 1573888);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_C + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 18);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 669696);
    CSB_Write(device, 27, 0);
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 799);
    #ifdef PRINT_STEP
    printf("start: step14!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step15 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.activate accel operator node, storage data in runtime1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 524288);
  CSB_Write(device, 195, ADDR_C);
  CSB_Write(device, 196, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 197, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 198, ADDR_B);
  CSB_Write(device, 199, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 200, (64 * (kvcache ? 1 : (token - last_token))));
  CSB_Write(device, 201, 592);
  CSB_Write(device, 202, 1);
  CSB_Write(device, 203, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 204, (kvcache ? 1 : (token - last_token)));
  CSB_Write(device, 205, 592);
  CSB_Write(device, 206, 18944);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 16);
#ifdef PRINT_STEP
printf("start: step15!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.activate run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step16 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime2 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+146-1)/146-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*146));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 3584);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 146 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 1152);
    CSB_Write(device, 8, 512);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 146: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_A + ((out_w * 146) * 64)));
    CSB_Write(device, 11, 475136);
    CSB_Write(device, 12, 14848);
    CSB_Write(device, 13, (ADDR_C + ((out_w * 146) * 64)));
    CSB_Write(device, 14, 16);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 2);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 1536);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 593920);
    CSB_Write(device, 27, ADDR_B + ((out_w * 146) * 64));
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 1823);
    #ifdef PRINT_STEP
    printf("start: step16!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn_res run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step17 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime2 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  int seq=token-last_token;
  int wout_split_times_minus1 = (seq+27-1)/27-1;
  int out_w_slice_last = (seq-(wout_split_times_minus1*27));
  for (int out_w = 0; out_w < (wout_split_times_minus1 + 1); out_w += 1) {
    CSB_Write(device, 2, 18944);
    CSB_Write(device, 3, ((out_w < wout_split_times_minus1) ? 27 : out_w_slice_last));
    CSB_Write(device, 4, 1);
    CSB_Write(device, 5, ((out_w < wout_split_times_minus1) ? 27: out_w_slice_last));
    CSB_Write(device, 6, 1);
    CSB_Write(device, 7, 192);
    CSB_Write(device, 8, 128);
    CSB_Write(device, 9, ((out_w < wout_split_times_minus1) ? 27: out_w_slice_last));
    CSB_Write(device, 10, (ADDR_C + ((out_w * 27) * 64)));
    CSB_Write(device, 11, 2672640);
    CSB_Write(device, 12, 78336);
    CSB_Write(device, 13, (ADDR_A + ((out_w * 27) * 64)));
    CSB_Write(device, 14, 18);
    CSB_Write(device, 15, 28);
    CSB_Write(device, 16, 0);
    CSB_Write(device, 17, 0);
    CSB_Write(device, 18, 0);
    CSB_Write(device, 19, 0);
    CSB_Write(device, 20, 0);
    CSB_Write(device, 21, 0);
    CSB_Write(device, 22, 5769216);
    CSB_Write(device, 23, 3670144);
    CSB_Write(device, 24, 512);
    CSB_Write(device, 25, 0);
    CSB_Write(device, 26, 745472);
    CSB_Write(device, 27, ADDR_D + ((out_w * 27) * 64));
    CSB_Write(device, 28, 0);
    CSB_Write(device, 29, (seq * 64));
    CSB_Write(device, 30, (seq * 64));
    CSB_Write(device, 31, (seq * 64));
    CSB_Write(device, 32, (seq * 64));
    CSB_Write(device, 33, 1823);
    #ifdef PRINT_STEP
    printf("start: step17!\n");
    #endif
    while(CSB_Read(device, 1) != 1) {}
  }
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn_res run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step477 (HANDLE& device, int kvcache, int token, int last_token) {
// accel.hbm.layer_norm accel operator node, storage data in runtime1 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 194, 6897664);
  CSB_Write(device, 195, ((kvcache ? 0 : 1) ? (ADDR_A + (((token - last_token) - 1) * 64)) : 7520256));
  CSB_Write(device, 196, ((kvcache ? 0 : 1) ? (64 * (token - last_token)) : 64));
  CSB_Write(device, 197, ((kvcache ? 0 : 1) ? (64 * (token - last_token)) : 64));
  CSB_Write(device, 198, ADDR_E);
  CSB_Write(device, 199, 64);
  CSB_Write(device, 200, 64);
  CSB_Write(device, 201, 112);
  CSB_Write(device, 202, 1);
  CSB_Write(device, 203, 1);
  CSB_Write(device, 204, 1);
  CSB_Write(device, 205, 156818);
  CSB_Write(device, 206, 7);
  CSB_Write(device, 207, 0);
  CSB_Write(device, 208, 0);
  CSB_Write(device, 209, 32);
#ifdef PRINT_STEP
printf("start: step477!\n");
#endif
  while(CSB_Read(device, 193) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.layer_norm run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void step478 (HANDLE& device) {
// accel.hbm.mvm_bn accel operator node, storage data in runtime2 with 0 offset
#ifdef REGS_DEBUG
LARGE_INTEGER start_run;
LARGE_INTEGER stop_run;
LARGE_INTEGER freq;
double time_sec0;
QueryPerformanceFrequency(&freq);
QueryPerformanceCounter(&start_run);
for (int i = 0; i < 1000; i=i+1) {
#endif
  CSB_Write(device, 2, 3584);
  CSB_Write(device, 3, 1);
  CSB_Write(device, 4, 1);
  CSB_Write(device, 5, 1);
  CSB_Write(device, 6, 1);
  CSB_Write(device, 7, 1024);
  CSB_Write(device, 8, 512);
  CSB_Write(device, 9, 1);
  CSB_Write(device, 10, ADDR_E);
  CSB_Write(device, 11, 105541632);
  CSB_Write(device, 12, 14848);
  CSB_Write(device, 13, 99794944);
  CSB_Write(device, 14, 148);
  CSB_Write(device, 15, 28);
  CSB_Write(device, 16, 0);
  CSB_Write(device, 17, 957530112);
  CSB_Write(device, 18, 0);
  CSB_Write(device, 19, 0);
  CSB_Write(device, 20, 0);
  CSB_Write(device, 21, 0);
  CSB_Write(device, 22, 5769216);
  CSB_Write(device, 23, 3670144);
  CSB_Write(device, 24, 1536);
  CSB_Write(device, 25, 0);
  CSB_Write(device, 26, 6912000);
  CSB_Write(device, 27, 0);
  CSB_Write(device, 28, 0);
  CSB_Write(device, 29, 64);
  CSB_Write(device, 30, 64);
  CSB_Write(device, 31, 64);
  CSB_Write(device, 32, 64);
  CSB_Write(device, 33, 2847);
#ifdef PRINT_STEP
printf("start: step478!\n");
#endif
  while(CSB_Read(device, 1) != 1) {}
#ifdef REGS_DEBUG
}
QueryPerformanceCounter(&stop_run);
time_sec0 = (unsigned long long)(stop_run.QuadPart - start_run.QuadPart) / (double)freq.QuadPart;
printf("accel.hbm.mvm_bn run time     = %fs(1000 times), %fs(1 times) \n",time_sec0, time_sec0/1000);
#endif
}

void qwen2_2048_lite_wt2hbm_0927_1041(HANDLE& device,  int token, int kvcache, int last_token) {
  //BLOCK 00
  step1(device, kvcache, token, last_token);
  step2(device, kvcache, token, last_token);
  step3(device, kvcache, token, last_token);
  step4(device, kvcache, token, last_token);
  step5(device, kvcache, token, last_token);
  step6(device, kvcache, token, last_token);
  step7(device, kvcache, token, last_token);
  step8(device, kvcache, token, last_token);
  step9(device, kvcache, token, last_token);
  step10(device, kvcache, token, last_token);
  step11(device, kvcache, token, last_token);
  step12(device, kvcache, token, last_token);
  step13(device, kvcache, token, last_token);
  step14(device, kvcache, token, last_token);
  step15(device, kvcache, token, last_token);
  step16(device, kvcache, token, last_token);
  step17(device, kvcache, token, last_token);
  //OUTPUT
  step477(device, kvcache, token, last_token);
  step478(device);

}
